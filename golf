#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <vector>
#include <algorithm>

using namespace std;

//struct to contain player's name, score, club name for a SINGLE ROUND
struct Round {
    string name;  // Player's name
    int score;    // Score
    string club;  // Club name
};

// Trim from both sides of string
string trim(const string& str) {
    size_t first = str.find_first_not_of(" \t\r\n");
    if (first == string::npos) return ""; // Empty or all spaces
    size_t last = str.find_last_not_of(" \t\r\n");
    return str.substr(first, (last - first + 1));
}

// Processing file function
bool processFile(const string& filename, map<string, vector<Round>>& data, map<string, set<string>>& clubs) {
    ifstream file(filename);
    if (!file) {
        cerr << "Error: The specified file cannot be opened!" << endl;
        return false;
    }

    string line;
    while (getline(file, line)) {
        if (line.empty()) continue; // Skip empty lines

        stringstream ss(line);
        string location, golfClub, player, scoreStr;
        int score;

        if (!getline(ss, location, ';') || !getline(ss, golfClub, ';') ||
            !getline(ss, player, ';') || !getline(ss, scoreStr, ';')) {
            cerr << "Error: The specified file has an erroneous line!" << endl;
            cerr << "Problematic line: " << line << endl;
            return false;
        }

        location = trim(location);
        golfClub = trim(golfClub);
        player = trim(player);
        scoreStr = trim(scoreStr);

        if (location.empty() || golfClub.empty() || player.empty() || scoreStr.empty()) {
            cerr << "Error: A line has an empty value!" << endl;
            cerr << "Problematic line: " << line << endl;
            return false;
        }

        try {
            score = stoi(scoreStr);
        } catch (const invalid_argument&) {
            cerr << "Error: Invalid score format in line: " << line << endl;
            return false;
        } catch (const out_of_range&) {
            cerr << "Error: Score out of range in line: " << line << endl;
            return false;
        }

        data[player].push_back({player, score, golfClub});
        clubs[location].insert(golfClub);  // Ensures unique clubs per location
    }
    file.close();
    return true;
}

//HCP calculator
double calculateHCP(const vector<Round>& rounds) {
    if (rounds.size() < 3) return 55.0;
    vector<int> scores;
    for (const auto& round : rounds) scores.push_back(round.score);
    sort(scores.begin(), scores.end());
    int count = min((int)scores.size(), 5);
    double sum = 0;
    for (int i = 0; i < count; i++) sum += scores[i];
    return sum / count;
}

//Print function for a "Played [player]" command, uses HCP function to calculate HCP and print the according strings
void displayPlayed(const map<string, vector<Round>>& data, const string& player) {
    auto it = data.find(player);
    if (it == data.end()) {
        cout << "Error: The player hasn't played any rounds!" << endl;
        return;
    }
    double hcp = calculateHCP(it->second);
    cout << player << " has " << it->second.size() << " rounds of golf";
    if (hcp == 55.0) cout << ", but hasn't played enough for a handicap.";
    else cout << ", with HCP of " << hcp;
    cout << endl;
    for (const auto& round : it->second) {
        cout << round.club << " : " << round.score << endl;
    }
}

// Print function for "clubs [location]" command
void displayClubs(const map<string, set<string>>& clubs, const string& location) {
    auto it = clubs.find(location);
    if (it == clubs.end()) {
        cout << "Error: The given location not found!" << endl;
        return;
    }

    for (const auto& club : it->second) {
        cout << "--" << club << endl;
    }
}

// Print function for "rounds [club]" command
void displayRounds(const map<string, vector<Round>>& data, const string& club) {
    vector<Round> rounds;
    for (const auto& player : data) {
        for (const auto& round : player.second) {
            if (round.club == club) {
                rounds.push_back(round);
            }
        }
    }

    if (rounds.empty()) {
        cout << "Error: The given club not found!" << endl;
        return;
    }

    sort(rounds.begin(), rounds.end(), [](const Round& a, const Round& b) {
        return a.score < b.score;
    });

    for (const auto& round : rounds) {
        cout << round.name << " : " << round.score << endl;
    }
}

// Print function for "places" command
void displayPlaces(const map<string, set<string>>& clubs) {
    vector<string> locations;
    for (const auto& entry : clubs) {
        locations.push_back(entry.first);
    }

    sort(locations.begin(), locations.end());

    for (const auto& location : locations) {
        cout << location << endl;
        for (const auto& club : clubs.at(location)) {
            cout << "--" << club << endl;
        }
    }
}

int main() {
    string filename;
    cout << "Input file: ";
    cin >> filename;

    map<string, vector<Round>> data;
    map<string, set<string>> clubs;  // Changed to set<string> to store unique clubs
    if (!processFile(filename, data, clubs)) {
        return EXIT_FAILURE;
    }

    string command, argument;
    while (true) {
        cout << "> ";
        cin >> command;
        if (command == "places") {
             displayPlaces(clubs);
        }
        cin.ignore(); // ensures getline function actually reads the argument after the cin command.
        getline(cin, argument);
        argument = trim(argument);

        if (command == "exit") {
            break;
        } else if (command == "played") {
            displayPlayed(data, argument);
        } else if (command == "clubs") {
            displayClubs(clubs, argument);
        } else if (command == "rounds") {
            displayRounds(data, argument);
        } else {
            cout << "Unknown command!" << endl;
        }
    }

    return EXIT_SUCCESS;
}
